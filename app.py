from flask import Flask, render_template, request
import subprocess
from pathlib import Path
import json
import re
import subprocess
import os
import io
from flask import send_file, request, jsonify, make_response

app = Flask(__name__)

TERRAFORM_DIR = Path(__file__).parent / "terraform"

# ðŸ”¹ You can change these to match your project
AWS_REGION = "us-east-1"
PROJECT_NAME = "AWS Secure Web Hosting (Minor Project)"



# list of allowed variable keys â€” must match variables.tf names you expect
ALLOWED_VARS = [
    "aws_region", "aws_access_key", "aws_secret_key", "instance_type",
    "key_name", "domain_name", "github_repo_url", "allow_ssh_cidr",
    # add any future vars like asg_min_size, enable_alb, etc.
]

def format_tfvars_template():
    """
    Returns bytes of a default terraform.tfvars template (HCL style)
    with placeholders and short comments.
    """
    content = """\
# terraform.tfvars - template generated by Terraform Control Panel
# Fill values below (keep quotes for strings). Save and upload from UI.

# AWS region (e.g., us-east-1)
aws_region = "us-east-1"

# AWS access key ID (optional â€” recommend using aws configure)
aws_access_key = ""

# AWS secret access key
aws_secret_key = ""

# EC2 instance type
instance_type = "t2.micro"

# Existing EC2 key pair name
key_name = "my-ec2-key"

# Your domain name (example.com)
domain_name = "example.com"

# GitHub repo containing website (https://github.com/user/repo)
github_repo_url = "https://github.com/user/repo"

# CIDR allowed to SSH (e.g., your-ip/32 or 0.0.0.0/0 for demo)
allow_ssh_cidr = "0.0.0.0/0"
"""
    return content.encode("utf-8")

@app.route("/download-template", methods=["GET"])
def download_template():
    """Return a terraform.tfvars template for users to download."""
    data = format_tfvars_template()
    return send_file(
        io.BytesIO(data),
        as_attachment=True,
        download_name="terraform.tfvars",
        mimetype="text/plain",
    )

def parse_tfvars_text(text):
    """
    Very small, safe parser for simple terraform.tfvars files with lines like:
    key = "value"
    Returns dict of key->value (strings). Ignores lines without '='.
    """
    result = {}
    # naive pattern: key = "value" or key = value (no quotes)
    pattern = re.compile(r'^\s*([A-Za-z0-9_]+)\s*=\s*(?:"([^"]*)"|([^#\n]+))')
    for line in text.splitlines():
        m = pattern.match(line)
        if m:
            key = m.group(1).strip()
            val = m.group(2) if m.group(2) is not None else (m.group(3) or "").strip()
            # strip possible trailing commas or comments
            val = re.sub(r'[,\s]*(#.*)?$', '', val).strip()
            if key in ALLOWED_VARS:
                result[key] = val
    return result

@app.route("/upload-tfvars", methods=["POST"])
def upload_tfvars():
    """
    Accepts a file upload (tfvars or json). Parses and returns JSON with found vars.
    Frontend will use this to pre-fill the form.
    """
    if "file" not in request.files:
        return jsonify({"ok": False, "error": "No file sent"}), 400
    f = request.files["file"]
    filename = f.filename or ""
    content = f.read().decode("utf-8", errors="ignore")
    parsed = {}

    if filename.endswith(".json") or filename.endswith(".tfvars.json"):
        try:
            j = json.loads(content)
            # take allowed keys only
            parsed = {k: str(v) for k, v in j.items() if k in ALLOWED_VARS}
        except Exception as e:
            return jsonify({"ok": False, "error": f"JSON parse error: {e}"}), 400
    else:
        # parse .tfvars (simple heuristic)
        parsed = parse_tfvars_text(content)

    if not parsed:
        return jsonify({"ok": False, "error": "No recognized variables found in file."}), 400

    # return the parsed variables to the frontend to auto-fill the form
    return jsonify({"ok": True, "vars": parsed})

def run_terraform_command(args):
    try:
        process = subprocess.run(
            args,
            cwd=TERRAFORM_DIR,
            capture_output=True,
            text=True
        )
        output = (
            f"$ {' '.join(args)}\n\n"
            f"--- STDOUT ---\n{process.stdout}\n"
            f"--- STDERR ---\n{process.stderr}"
        )
        return process.returncode, output
    except Exception as e:
        return 1, f"Error while running command: {e}"

ANSI_RE = re.compile(r'\x1B\[[0-?]*[ -/]*[@-~]')

def strip_ansi(text: str) -> str:
    if not text:
        return ""
    return ANSI_RE.sub("", text)

def get_name_servers():
    """
    Returns (ns_list, error_message_clean).
    Uses terraform output -json -no-color to avoid ANSI colors and gets a JSON array.
    If not found, returns ([], clean_error).
    """
    try:
        # Ensure Terraform prints no color. Also set cwd if needed.
        env = os.environ.copy()
        # Some terraform versions may still colorize depending on TERM; force no-color
        env.update({"TF_CLI_ARGS": "-no-color"})

        process = subprocess.run(
            ["terraform", "output", "-json", "name_servers", "-no-color"],
            cwd=str(TERRAFORM_DIR),
            capture_output=True,
            text=True,
            env=env,
            timeout=30,
        )

        stdout = strip_ansi(process.stdout)
        stderr = strip_ansi(process.stderr)

        if process.returncode != 0:
            # Terraform returned an error (e.g. output not found). Return cleaned stderr.
            # If stderr empty, show stdout as fallback.
            err = stderr or stdout or "Unknown error fetching Terraform output."
            return [], err.strip()

        # parse json; terraform -json returns a JSON value (often list).
        try:
            ns_list = json.loads(stdout)
            # ensure it's a list of strings
            if isinstance(ns_list, list):
                return ns_list, ""
            # some configs return object â€” normalize
            return [], "Unexpected output format from terraform output."
        except json.JSONDecodeError:
            # If JSON parse fails, return raw cleaned output as error message
            return [], ("Failed to parse terraform output as JSON: " + stdout.strip())

    except subprocess.TimeoutExpired:
        return [], "Timed out while fetching name servers from Terraform."
    except Exception as e:
        return [], f"Error fetching NS records: {e}"


def write_tfvars(config):
    lines = [
        f'aws_region      = "{config["aws_region"]}"',
        f'aws_access_key  = "{config["aws_access_key"]}"',
        f'aws_secret_key  = "{config["aws_secret_key"]}"',
        f'instance_type   = "{config["instance_type"]}"',
        f'key_name        = "{config["key_name"]}"',
        f'domain_name     = "{config["domain_name"]}"',
        f'github_repo_url = "{config["github_repo_url"]}"',
        f'allow_ssh_cidr  = "{config["allow_ssh_cidr"]}"',
    ]
    tfvars_path = TERRAFORM_DIR / "terraform.tfvars"
    tfvars_path.write_text("\n".join(lines))

@app.route("/", methods=["GET", "POST"])
def index():
    last_output = ""
    last_cmd = ""
    exit_code = None

    # default values for form
    cfg = {
        "aws_region": AWS_REGION,      # from your constant
        "domain_name": "",
        "github_repo_url": "",
        "key_name": "",
        "aws_access_key": "",
        "aws_secret_key": "",
        "instance_type": "t2.micro",
        "allow_ssh_cidr": "0.0.0.0/0",
    }

    if request.method == "POST":
        # read values from form
        cfg["aws_region"]      = request.form.get("aws_region", "").strip() or AWS_REGION
        cfg["domain_name"]     = request.form.get("domain_name", "").strip()
        cfg["github_repo_url"] = request.form.get("github_repo_url", "").strip()
        cfg["key_name"]        = request.form.get("key_name", "").strip()
        cfg["aws_access_key"]  = request.form.get("aws_access_key", "").strip()
        cfg["aws_secret_key"]  = request.form.get("aws_secret_key", "").strip()
        cfg["allow_ssh_cidr"]  = request.form.get("allow_ssh_cidr", "").strip() or "0.0.0.0/0"

        action = request.form.get("action")

        # before plan/apply/destroy â†’ write tfvars
        if action in ("plan", "apply", "destroy"):
            write_tfvars(cfg)

        # your existing command handling
        if action == "init":
            last_cmd = "terraform init"
            exit_code, last_output = run_terraform_command(["terraform", "init"])
        elif action == "validate":
            last_cmd = "terraform validate"
            exit_code, last_output = run_terraform_command(["terraform", "validate"])
        elif action == "plan":
            last_cmd = "terraform plan"
            exit_code, last_output = run_terraform_command(["terraform", "plan"])
        elif action == "apply":
            last_cmd = "terraform apply -auto-approve"
            exit_code, last_output = run_terraform_command(
                ["terraform", "apply", "-auto-approve"]
            )
        elif action == "destroy":
            last_cmd = "terraform destroy -auto-approve"
            exit_code, last_output = run_terraform_command(
                ["terraform", "destroy", "-auto-approve"]
            )

    ns_records, ns_error = get_name_servers()

    return render_template(
        "index.html",
        last_cmd=last_cmd,
        last_output=last_output,
        exit_code=exit_code,
        aws_region=AWS_REGION,
        project_name=PROJECT_NAME,
        ns_records=ns_records,
        ns_error=ns_error,
        # pass config back to template
        cfg_aws_region=cfg["aws_region"],
        cfg_domain_name=cfg["domain_name"],
        cfg_github_repo_url=cfg["github_repo_url"],
        cfg_key_name=cfg["key_name"],
        cfg_aws_access_key=cfg["aws_access_key"],
        cfg_aws_secret_key=cfg["aws_secret_key"],
        cfg_allow_ssh_cidr=cfg["allow_ssh_cidr"],
    )


if __name__ == "__main__":
    app.run(host="127.0.0.1", port=5000, debug=True)
